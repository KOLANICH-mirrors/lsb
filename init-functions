# /lib/lsb/init-functions for Debian -*- shell-script -*-
#
#Copyright (c) 2002-03 Chris Lawrence
#All rights reserved.
#
#Redistribution and use in source and binary forms, with or without
#modification, are permitted provided that the following conditions
#are met:
#1. Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimer.
#2. Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimer in the
#   documentation and/or other materials provided with the distribution.
#3. Neither the name of the author nor the names of other contributors
#   may be used to endorse or promote products derived from this software
#   without specific prior written permission.
#
#THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
#ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
#FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
#DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
#OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
#LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
#OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
#SUCH DAMAGE.

start_daemon () {
    local force nice pidfile exec
    set -- `POSIXLY_CORRECT=1 getopt "fn:p:" $*`
    force=0
    nice=0
    pidfile=/dev/null

    for i in $*; do
        case $i in
            -f)  force=1; shift;;
            -n)  nice=$2; shift 2;;
            -p)  pidfile=$2; shift 2;;
            --)  shift; break;;
        esac
    done

    exec=$1; shift

    if [ $force = 1 ]; then
        /sbin/start-stop-daemon --start --nicelevel $nice --quiet --startas $exec --pidfile /dev/null --oknodo -- $*
    elif [ $pidfile ]; then
        /sbin/start-stop-daemon --start --nicelevel $nice --quiet --exec $exec --oknodo --pidfile "$pidfile" -- $*
    else
        /sbin/start-stop-daemon --start --nicelevel $nice --quiet --exec $exec --oknodo -- $*
    fi
}

pidofproc () {
    local pidfile line i pids= status
    set -- `POSIXLY_CORRECT=1 getopt "p:" $*`
    pidfile=

    for i in $*; do
        case $i in
            -p)  pidfile=$2; shift 2;;
            --)  shift; break;;
        esac
    done

    if [ -z "$pidfile" ]; then
        pidfile=/var/run/$(basename "$1").pid
    fi

    if [ -f "$pidfile" ]; then
        read -d "" line < "$pidfile"
        for i in $line; do
            [ -z "${p//[0-9]/}" -a -d "/proc/$i" ] && pids="$i $pids"
        done
        if [ -n "$pids" ]; then
            echo "$pids"
            return 0
        else
            return 2 # program is dead and /var/run pid file exists
        fi
    elif [ -x /bin/pidof ]; then
        /bin/pidof -o %PPID $1
        status="$?"
        [ "$status" = 1 ] && return 3 # program is not running
        return 0
    else
        return 4 # program or service is unknown
    fi
}

# start-stop-daemon uses the same algorithm as "pidofproc" above.
killproc () {
    local pidfile sig status
    set -- `POSIXLY_CORRECT=1 getopt "p:" $*`
    pidfile=

    for i in $*; do
        case $i in
            -p)  pidfile=$2; shift 2;;
            --)  shift; break;;
        esac
    done

    if [ ! $pidfile ]; then
        pidfile=/var/run/$(basename "$1").pid
    fi

    if [ $2 ]; then
        sig=$(echo $2 | sed -e 's/^-\(.*\)/\1/')
        sig=$(echo $sig | sed -e 's/^SIG\(.*\)/\1/')
        /sbin/start-stop-daemon --stop --pidfile "$pidfile" --signal $sig --quiet
        status="$?"
        [ "$status" = 1 ] && return 3 # program is not running
        return 0
    else
        /sbin/start-stop-daemon --stop --pidfile "$pidfile" --retry 5 --quiet --oknodo
    fi
}

log_msg() {
    local esc extd warn done norm stat
    local rc_done rc_warning rc_failure
    if test -z "$LINES" -o -z "$COLUMNS" ; then
        eval `stty size 2>/dev/null | (read L C; \
       echo LINES=${L:-24} COLUMNS=${C:-80})`
    fi

    test $LINES   -eq 0 && LINES=24
    test $COLUMNS -eq 0 && COLUMNS=80
    export LINES COLUMNS

    if test -t 1 -a "$TERM" != "raw" -a "$TERM" != "dumb" && stty size > /dev/null 2>&1 ; then
        esc=`echo -en "\033"`
        extd="${esc}[1m"
        warn="${esc}[1;31m"
        done="${esc}[1;32m"
        attn="${esc}[1;33m"
        norm=`echo -en "${esc}[m\017"`
        done="${esc}[1;32m"
        attn="${esc}[1;33m"
        norm=`echo -en "${esc}[m\017"`
        stat=`echo -en "\015${esc}[${COLUMNS}C${esc}[10D"`
        
        rc_done="${stat}${done}done${norm}"
        rc_warning="${stat}${attn}warning${norm}"
        rc_failure="${stat}${warn}failed${norm}"
    else
        esc=".."
        norm=
        warn=

        rc_done="..done"
        rc_warning="..warning"
        rc_failed="..failed"
    fi
    case "$1" in
        done)
            echo "$2$rc_done"
            ;;
        warning)
           echo "$2$rc_warning"
        ;;
        failure)
           echo "$2$rc_failure"
        ;;
        *)
           echo "$2${stat}${attn}$1${norm}"
        ;;
    esac
}

log_success_msg () {
    log_msg "done" "$1"
}
log_failure_msg () {
    log_msg "failure" "$1"
}
log_warning_msg () {
    log_msg "warning" "$1"
}
